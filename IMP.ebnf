Letter = 'a' .. 'z' | 'A' .. 'Z'
Digit = '0' .. '9'
Ident = Letter { Letter | Digit }
Numeral = [ '-' ] ( Digit | Numeral Digit )
Bool = 'true' | 'false'

Aop = '+' | '-' | '*'                                                               (* arithmetic operation *)
Aexp = Aterm { Aop Term }                                                           (* arithmetic expression *)
Aterm
    = Ident                                                                         (* variable *)
    | Numeral                                                                       (* value *)
    | '(' Aexp ')'                                                                  (* parenthesized expression *)

Rop = '=' | '#' | '<' | '<=' | '>' | '>='                                           (* relation operation *)
Bop = 'and' | 'or'                                                                  (* boolean operation *)
Bexp = Bterm { Bop Bterm }                                                          (* boolean expression *)
Bterm
    = Bool                                                                          (* value *)
    | 'not' Bexp                                                                    (* negation *)
    | Aexp Rop Aexp                                                                 (* relation *)
    | '(' Bexp ')'                                                                  (* parenthesized expression *)

Stm
    = 'skip'                                                                        (* no-op *)
    | ( Ident | '_' ) ':=' Aexp                                                     (* definition *)
    | Stm ';' Stm                                                                   (* sequence *)
    | 'if' Bexp 'then' Stm 'else' Stm 'end'                                         (* conditional *)
    | 'while' Bexp 'do' Stm 'end'                                                   (* iteration *)
    | 'var' Ident ':=' Aexp 'in' Stm 'end'                                          (* local variable definition *)
    | 'procedure' Ident '(' Params ';' Rets ')' 'begin' Stm 'end'                   (* procedure definition *)
    | Ident '(' Args ';' Rets ')'                                                   (* procedure invocation *)
    | Stm '||' Stm                                                                  (* non-determinism *)
    | Stm 'par' Stm                                                                 (* parallelization *)
    | '(' Stm ')'                                                                   (* parenthesized statement *)

Args = [ Aexp { ',' Aexp } ]                                                        (* zero or more comma separated Aexp *)
Params = [ Ident { ',' Ident } ]                                                    (* '' .. Ident *)
Rets = Params                                                                       (* '' .. *)

Construct
    = Aexp
    | Bexp
    | Stm
